import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/asciichart/asciichart.js
var require_asciichart = __commonJS({
  "node_modules/asciichart/asciichart.js"(exports) {
    (function(exports2) {
      exports2.black = "\x1B[30m";
      exports2.red = "\x1B[31m";
      exports2.green = "\x1B[32m";
      exports2.yellow = "\x1B[33m";
      exports2.blue = "\x1B[34m";
      exports2.magenta = "\x1B[35m";
      exports2.cyan = "\x1B[36m";
      exports2.lightgray = "\x1B[37m";
      exports2.default = "\x1B[39m";
      exports2.darkgray = "\x1B[90m";
      exports2.lightred = "\x1B[91m";
      exports2.lightgreen = "\x1B[92m";
      exports2.lightyellow = "\x1B[93m";
      exports2.lightblue = "\x1B[94m";
      exports2.lightmagenta = "\x1B[95m";
      exports2.lightcyan = "\x1B[96m";
      exports2.white = "\x1B[97m";
      exports2.reset = "\x1B[0m";
      function colored(char, color) {
        return color === void 0 ? char : color + char + exports2.reset;
      }
      exports2.colored = colored;
      exports2.plot = function(series, cfg = void 0) {
        if (typeof series[0] == "number") {
          series = [series];
        }
        cfg = typeof cfg !== "undefined" ? cfg : {};
        let min = typeof cfg.min !== "undefined" ? cfg.min : series[0][0];
        let max = typeof cfg.max !== "undefined" ? cfg.max : series[0][0];
        for (let j = 0; j < series.length; j++) {
          for (let i = 0; i < series[j].length; i++) {
            min = Math.min(min, series[j][i]);
            max = Math.max(max, series[j][i]);
          }
        }
        let defaultSymbols = ["┼", "┤", "╶", "╴", "─", "╰", "╭", "╮", "╯", "│"];
        let range = Math.abs(max - min);
        let offset = typeof cfg.offset !== "undefined" ? cfg.offset : 3;
        let padding = typeof cfg.padding !== "undefined" ? cfg.padding : "           ";
        let height = typeof cfg.height !== "undefined" ? cfg.height : range;
        let colors = typeof cfg.colors !== "undefined" ? cfg.colors : [];
        let ratio = range !== 0 ? height / range : 1;
        let min2 = Math.round(min * ratio);
        let max2 = Math.round(max * ratio);
        let rows = Math.abs(max2 - min2);
        let width = 0;
        for (let i = 0; i < series.length; i++) {
          width = Math.max(width, series[i].length);
        }
        width = width + offset;
        let symbols = typeof cfg.symbols !== "undefined" ? cfg.symbols : defaultSymbols;
        let format = typeof cfg.format !== "undefined" ? cfg.format : function(x) {
          return (padding + x.toFixed(2)).slice(-padding.length);
        };
        let result = new Array(rows + 1);
        for (let i = 0; i <= rows; i++) {
          result[i] = new Array(width);
          for (let j = 0; j < width; j++) {
            result[i][j] = " ";
          }
        }
        for (let y = min2; y <= max2; ++y) {
          let label = format(rows > 0 ? max - (y - min2) * range / rows : y, y - min2);
          result[y - min2][Math.max(offset - label.length, 0)] = label;
          result[y - min2][offset - 1] = y == 0 ? symbols[0] : symbols[1];
        }
        for (let j = 0; j < series.length; j++) {
          let currentColor = colors[j % colors.length];
          let y0 = Math.round(series[j][0] * ratio) - min2;
          result[rows - y0][offset - 1] = colored(symbols[0], currentColor);
          for (let x = 0; x < series[j].length - 1; x++) {
            let y02 = Math.round(series[j][x + 0] * ratio) - min2;
            let y1 = Math.round(series[j][x + 1] * ratio) - min2;
            if (y02 == y1) {
              result[rows - y02][x + offset] = colored(symbols[4], currentColor);
            } else {
              result[rows - y1][x + offset] = colored(y02 > y1 ? symbols[5] : symbols[6], currentColor);
              result[rows - y02][x + offset] = colored(y02 > y1 ? symbols[7] : symbols[8], currentColor);
              let from = Math.min(y02, y1);
              let to = Math.max(y02, y1);
              for (let y = from + 1; y < to; y++) {
                result[rows - y][x + offset] = colored(symbols[9], currentColor);
              }
            }
          }
        }
        return result.map(function(x) {
          return x.join("");
        }).join("\n");
      };
    })(typeof exports === "undefined" ? (
      /* istanbul ignore next */
      exports["asciichart"] = {}
    ) : exports);
  }
});
export default require_asciichart();
//# sourceMappingURL=asciichart.js.map
